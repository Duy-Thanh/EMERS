/**
 * StockPredict JNI Bridge Implementation
 * Connects Java GUI to C data mining functions
 */

#include <jni.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "../include/emers.h"
#include "../include/data_mining.h"
#include "../include/technical_analysis.h"
#include "gui_StockPredictJNIBridge.h" // This will be generated by javah

// Helper function to convert Java arrays to StockData
static StockData* convertJavaArraysToStockData(JNIEnv *env, jobjectArray jdates, 
                                             jdoubleArray jopens, jdoubleArray jhighs, 
                                             jdoubleArray jlows, jdoubleArray jcloses, 
                                             jdoubleArray jvolumes, jint dataSize) {
    
    StockData* data = (StockData*)malloc(dataSize * sizeof(StockData));
    if (!data) {
        return NULL;
    }
    
    // Get Java array elements
    jdouble* opens = (*env)->GetDoubleArrayElements(env, jopens, NULL);
    jdouble* highs = (*env)->GetDoubleArrayElements(env, jhighs, NULL);
    jdouble* lows = (*env)->GetDoubleArrayElements(env, jlows, NULL);
    jdouble* closes = (*env)->GetDoubleArrayElements(env, jcloses, NULL);
    jdouble* volumes = (*env)->GetDoubleArrayElements(env, jvolumes, NULL);
    
    // Copy data
    for (int i = 0; i < dataSize; i++) {
        // Get date string
        jstring jdate = (jstring)(*env)->GetObjectArrayElement(env, jdates, i);
        const char* dateStr = (*env)->GetStringUTFChars(env, jdate, NULL);
        
        // Copy date (truncate if needed)
        strncpy(data[i].date, dateStr, sizeof(data[i].date) - 1);
        data[i].date[sizeof(data[i].date) - 1] = '\0';
        
        // Copy numeric data
        data[i].open = opens[i];
        data[i].high = highs[i];
        data[i].low = lows[i];
        data[i].close = closes[i];
        data[i].volume = volumes[i];
        
        // Initialize other fields
        data[i].adjClose = closes[i]; // Use close price as adjusted close
        
        // Release date string
        (*env)->ReleaseStringUTFChars(env, jdate, dateStr);
        (*env)->DeleteLocalRef(env, jdate);
    }
    
    // Release Java arrays
    (*env)->ReleaseDoubleArrayElements(env, jopens, opens, JNI_ABORT);
    (*env)->ReleaseDoubleArrayElements(env, jhighs, highs, JNI_ABORT);
    (*env)->ReleaseDoubleArrayElements(env, jlows, lows, JNI_ABORT);
    (*env)->ReleaseDoubleArrayElements(env, jcloses, closes, JNI_ABORT);
    (*env)->ReleaseDoubleArrayElements(env, jvolumes, volumes, JNI_ABORT);
    
    return data;
}

// Helper function to create Java 2D double array
static jobjectArray create2DDoubleArray(JNIEnv *env, jdouble** data, int rows, int cols) {
    // Create the double[] class object
    jclass doubleArrayClass = (*env)->FindClass(env, "[D");
    
    // Create the double[][] array
    jobjectArray result = (*env)->NewObjectArray(env, rows, doubleArrayClass, NULL);
    
    // Fill the array
    for (int i = 0; i < rows; i++) {
        jdoubleArray row = (*env)->NewDoubleArray(env, cols);
        (*env)->SetDoubleArrayRegion(env, row, 0, cols, data[i]);
        (*env)->SetObjectArrayElement(env, result, i, row);
        (*env)->DeleteLocalRef(env, row);
    }
    
    return result;
}

/*
 * Initialize the bridge
 */
JNIEXPORT jint JNICALL Java_gui_StockPredictJNIBridge_initializeBridge
  (JNIEnv *env, jobject obj) {
    // Initialization code here
    return 0;
}

/*
 * Clean up resources
 */
JNIEXPORT void JNICALL Java_gui_StockPredictJNIBridge_cleanupBridge
  (JNIEnv *env, jobject obj) {
    // Cleanup code here
}

/*
 * Detect price patterns
 */
JNIEXPORT jobjectArray JNICALL Java_gui_StockPredictJNIBridge_detectPricePatterns
  (JNIEnv *env, jobject obj, jobjectArray jdates, jdoubleArray jopens, jdoubleArray jhighs, 
   jdoubleArray jlows, jdoubleArray jcloses, jdoubleArray jvolumes, jint dataSize) {
    
    // Convert Java arrays to StockData
    StockData* data = convertJavaArraysToStockData(env, jdates, jopens, jhighs, jlows, jcloses, jvolumes, dataSize);
    if (!data) {
        return NULL;
    }
    
    // Allocate patterns array
    int maxPatterns = 20; // Adjust as needed
    MarketPattern* patterns = (MarketPattern*)malloc(maxPatterns * sizeof(MarketPattern));
    if (!patterns) {
        free(data);
        return NULL;
    }
    
    // Detect patterns
    int patternCount = detectPricePatterns(data, dataSize, patterns, maxPatterns);
    
    // Create result array
    jdouble** resultData = (jdouble**)malloc(patternCount * sizeof(jdouble*));
    if (!resultData) {
        free(data);
        free(patterns);
        return NULL;
    }
    
    // Fill result array
    for (int i = 0; i < patternCount; i++) {
        resultData[i] = (jdouble*)malloc(5 * sizeof(jdouble));
        if (!resultData[i]) {
            // Handle allocation failure
            for (int j = 0; j < i; j++) {
                free(resultData[j]);
            }
            free(resultData);
            free(data);
            free(patterns);
            return NULL;
        }
        
        resultData[i][0] = (jdouble)patterns[i].type;
        resultData[i][1] = (jdouble)patterns[i].startIndex;
        resultData[i][2] = (jdouble)patterns[i].endIndex;
        resultData[i][3] = (jdouble)patterns[i].confidence;
        resultData[i][4] = (jdouble)2.5; // Placeholder for expected move
    }
    
    // Create Java array
    jobjectArray result = create2DDoubleArray(env, resultData, patternCount, 5);
    
    // Clean up
    for (int i = 0; i < patternCount; i++) {
        free(resultData[i]);
    }
    free(resultData);
    free(patterns);
    free(data);
    
    return result;
}

/*
 * Detect SMA crossover signals
 */
JNIEXPORT jobjectArray JNICALL Java_gui_StockPredictJNIBridge_detectSMACrossoverSignals
  (JNIEnv *env, jobject obj, jobjectArray jdates, jdoubleArray jopens, jdoubleArray jhighs,
   jdoubleArray jlows, jdoubleArray jcloses, jdoubleArray jvolumes, jint dataSize,
   jint shortPeriod, jint longPeriod) {
    
    // Convert Java arrays to StockData
    StockData* data = convertJavaArraysToStockData(env, jdates, jopens, jhighs, jlows, jcloses, jvolumes, dataSize);
    if (!data) {
        return NULL;
    }
    
    // Allocate signals array
    int maxSignals = 20; // Adjust as needed
    DMTradingSignal* signals = (DMTradingSignal*)malloc(maxSignals * sizeof(DMTradingSignal));
    if (!signals) {
        free(data);
        return NULL;
    }
    
    // Detect signals
    int signalCount = detectSMACrossoverSignals(data, dataSize, shortPeriod, longPeriod, signals, maxSignals);
    
    // Create result array
    jdouble** resultData = (jdouble**)malloc(signalCount * sizeof(jdouble*));
    if (!resultData) {
        free(data);
        free(signals);
        return NULL;
    }
    
    // Fill result array
    for (int i = 0; i < signalCount; i++) {
        resultData[i] = (jdouble*)malloc(7 * sizeof(jdouble));
        if (!resultData[i]) {
            // Handle allocation failure
            for (int j = 0; j < i; j++) {
                free(resultData[j]);
            }
            free(resultData);
            free(data);
            free(signals);
            return NULL;
        }
        
        resultData[i][0] = (jdouble)signals[i].type;
        resultData[i][1] = (jdouble)signals[i].signalIndex;
        resultData[i][2] = (jdouble)signals[i].confidence;
        resultData[i][3] = (jdouble)signals[i].entryPrice;
        resultData[i][4] = (jdouble)signals[i].targetPrice;
        resultData[i][5] = (jdouble)signals[i].stopLossPrice;
        resultData[i][6] = (jdouble)signals[i].riskRewardRatio;
    }
    
    // Create Java array
    jobjectArray result = create2DDoubleArray(env, resultData, signalCount, 7);
    
    // Clean up
    for (int i = 0; i < signalCount; i++) {
        free(resultData[i]);
    }
    free(resultData);
    free(signals);
    free(data);
    
    return result;
}

/*
 * Detect EMA crossover signals
 */
JNIEXPORT jobjectArray JNICALL Java_gui_StockPredictJNIBridge_detectEMACrossoverSignals
  (JNIEnv *env, jobject obj, jobjectArray jdates, jdoubleArray jopens, jdoubleArray jhighs,
   jdoubleArray jlows, jdoubleArray jcloses, jdoubleArray jvolumes, jint dataSize,
   jint shortPeriod, jint longPeriod) {
    
    // Convert Java arrays to StockData
    StockData* data = convertJavaArraysToStockData(env, jdates, jopens, jhighs, jlows, jcloses, jvolumes, dataSize);
    if (!data) {
        return NULL;
    }
    
    // Allocate signals array
    int maxSignals = 20; // Adjust as needed
    DMTradingSignal* signals = (DMTradingSignal*)malloc(maxSignals * sizeof(DMTradingSignal));
    if (!signals) {
        free(data);
        return NULL;
    }
    
    // Detect signals
    int signalCount = detectEMACrossoverSignals(data, dataSize, shortPeriod, longPeriod, signals, maxSignals);
    
    // Create result array
    jdouble** resultData = (jdouble**)malloc(signalCount * sizeof(jdouble*));
    if (!resultData) {
        free(data);
        free(signals);
        return NULL;
    }
    
    // Fill result array
    for (int i = 0; i < signalCount; i++) {
        resultData[i] = (jdouble*)malloc(7 * sizeof(jdouble));
        if (!resultData[i]) {
            // Handle allocation failure
            for (int j = 0; j < i; j++) {
                free(resultData[j]);
            }
            free(resultData);
            free(data);
            free(signals);
            return NULL;
        }
        
        resultData[i][0] = (jdouble)signals[i].type;
        resultData[i][1] = (jdouble)signals[i].signalIndex;
        resultData[i][2] = (jdouble)signals[i].confidence;
        resultData[i][3] = (jdouble)signals[i].entryPrice;
        resultData[i][4] = (jdouble)signals[i].targetPrice;
        resultData[i][5] = (jdouble)signals[i].stopLossPrice;
        resultData[i][6] = (jdouble)signals[i].riskRewardRatio;
    }
    
    // Create Java array
    jobjectArray result = create2DDoubleArray(env, resultData, signalCount, 7);
    
    // Clean up
    for (int i = 0; i < signalCount; i++) {
        free(resultData[i]);
    }
    free(resultData);
    free(signals);
    free(data);
    
    return result;
}

/*
 * Detect MACD crossover signals (this would require implementing a MACD crossover detection function in C)
 */
JNIEXPORT jobjectArray JNICALL Java_gui_StockPredictJNIBridge_detectMACDCrossoverSignals
  (JNIEnv *env, jobject obj, jobjectArray jdates, jdoubleArray jopens, jdoubleArray jhighs,
   jdoubleArray jlows, jdoubleArray jcloses, jdoubleArray jvolumes, jint dataSize,
   jint fastPeriod, jint slowPeriod, jint signalPeriod) {
    
    // Note: This function would require implementing a MACD crossover detection function
    // For demonstration purposes, we'll return a placeholder result
    
    // Create placeholder result (empty array for now)
    jclass doubleArrayClass = (*env)->FindClass(env, "[D");
    return (*env)->NewObjectArray(env, 0, doubleArrayClass, NULL);
}

/*
 * Detect anomalies
 */
JNIEXPORT jobjectArray JNICALL Java_gui_StockPredictJNIBridge_detectAnomalies
  (JNIEnv *env, jobject obj, jobjectArray jdates, jdoubleArray jopens, jdoubleArray jhighs,
   jdoubleArray jlows, jdoubleArray jcloses, jdoubleArray jvolumes, jint dataSize) {
    
    // Convert Java arrays to StockData
    StockData* data = convertJavaArraysToStockData(env, jdates, jopens, jhighs, jlows, jcloses, jvolumes, dataSize);
    if (!data) {
        return NULL;
    }
    
    // Allocate anomalies array
    int maxAnomalies = 20; // Adjust as needed
    AnomalyResult* anomalies = (AnomalyResult*)malloc(maxAnomalies * sizeof(AnomalyResult));
    if (!anomalies) {
        free(data);
        return NULL;
    }
    
    // Detect anomalies
    int anomalyCount = detectAnomalies(data, dataSize, anomalies, maxAnomalies);
    
    // Create result array
    jdouble** resultData = (jdouble**)malloc(anomalyCount * sizeof(jdouble*));
    if (!resultData) {
        free(data);
        free(anomalies);
        return NULL;
    }
    
    // Fill result array
    for (int i = 0; i < anomalyCount; i++) {
        resultData[i] = (jdouble*)malloc(4 * sizeof(jdouble));
        if (!resultData[i]) {
            // Handle allocation failure
            for (int j = 0; j < i; j++) {
                free(resultData[j]);
            }
            free(resultData);
            free(data);
            free(anomalies);
            return NULL;
        }
        
        resultData[i][0] = (jdouble)anomalies[i].index;
        resultData[i][1] = (jdouble)anomalies[i].score;
        resultData[i][2] = (jdouble)anomalies[i].priceDeviation;
        resultData[i][3] = (jdouble)anomalies[i].volumeDeviation;
    }
    
    // Create Java array
    jobjectArray result = create2DDoubleArray(env, resultData, anomalyCount, 4);
    
    // Clean up
    for (int i = 0; i < anomalyCount; i++) {
        free(resultData[i]);
    }
    free(resultData);
    free(anomalies);
    free(data);
    
    return result;
}

/*
 * Calculate technical indicators
 */
JNIEXPORT jobjectArray JNICALL Java_gui_StockPredictJNIBridge_calculateIndicators
  (JNIEnv *env, jobject obj, jobjectArray jdates, jdoubleArray jopens, jdoubleArray jhighs,
   jdoubleArray jlows, jdoubleArray jcloses, jdoubleArray jvolumes, jint dataSize,
   jintArray jindicators, jintArray jperiods) {
    
    // Convert Java arrays to StockData
    StockData* data = convertJavaArraysToStockData(env, jdates, jopens, jhighs, jlows, jcloses, jvolumes, dataSize);
    if (!data) {
        return NULL;
    }
    
    // Get indicator and period arrays
    jint* indicators = (*env)->GetIntArrayElements(env, jindicators, NULL);
    jint* periods = (*env)->GetIntArrayElements(env, jperiods, NULL);
    jint indicatorCount = (*env)->GetArrayLength(env, jindicators);
    
    // Create a TechnicalIndicators struct
    TechnicalIndicators techIndicators;
    
    // Calculate indicators
    calculateAllIndicators(data, dataSize, &techIndicators);
    
    // Create result array for indicators
    jdouble** resultData = (jdouble**)malloc(indicatorCount * sizeof(jdouble*));
    if (!resultData) {
        free(data);
        (*env)->ReleaseIntArrayElements(env, jindicators, indicators, JNI_ABORT);
        (*env)->ReleaseIntArrayElements(env, jperiods, periods, JNI_ABORT);
        return NULL;
    }
    
    // Fill result array with one row per indicator
    for (int i = 0; i < indicatorCount; i++) {
        resultData[i] = (jdouble*)malloc(sizeof(jdouble));
        if (!resultData[i]) {
            // Handle allocation failure
            for (int j = 0; j < i; j++) {
                free(resultData[j]);
            }
            free(resultData);
            free(data);
            (*env)->ReleaseIntArrayElements(env, jindicators, indicators, JNI_ABORT);
            (*env)->ReleaseIntArrayElements(env, jperiods, periods, JNI_ABORT);
            return NULL;
        }
        
        // Fill in specific indicator value
        switch (indicators[i]) {
            case 0: // SMA
                resultData[i][0] = techIndicators.sma;
                break;
            case 1: // EMA
                resultData[i][0] = techIndicators.ema;
                break;
            case 2: // RSI
                resultData[i][0] = techIndicators.rsi;
                break;
            case 3: // MACD
                resultData[i][0] = techIndicators.macd;
                break;
            case 4: // MACD Signal
                resultData[i][0] = techIndicators.macdSignal;
                break;
            case 5: // MACD Histogram
                resultData[i][0] = techIndicators.macdHistogram;
                break;
            default:
                resultData[i][0] = 0.0;
        }
    }
    
    // Create Java array
    jobjectArray result = create2DDoubleArray(env, resultData, indicatorCount, 1);
    
    // Clean up
    for (int i = 0; i < indicatorCount; i++) {
        free(resultData[i]);
    }
    free(resultData);
    free(data);
    (*env)->ReleaseIntArrayElements(env, jindicators, indicators, JNI_ABORT);
    (*env)->ReleaseIntArrayElements(env, jperiods, periods, JNI_ABORT);
    
    return result;
} 